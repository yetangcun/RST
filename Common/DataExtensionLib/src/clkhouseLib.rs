use std::error::Error;
use chrono::{DateTime,Utc,Local, TimeZone};
use clickhouse::{Client, Row};
use clickhouse::sql::Identifier;
use serde::{Deserialize, Serialize};

pub struct ClkHouseHdl {
    client: Client,
}

impl ClkHouseHdl {
    pub fn new(db_url: &str) -> Self {
        // 连接clickhouse的详细字符串示例，带账号密码和具体的数据库名称 
        // 连接示例: http://default:xiaoxiao@localhost:8123/blkdb
        // default: 账号
        // xiaoxiao: 密码 
        // localhost: 主机地址
        // 8123: 端口号
        // blkdb: 数据库名称
        // let client = Client::default().with_url(db_url); // db_url格式: http://username:password@localhost:8123/dbname
        let client = Client::default().with_url(db_url)
        // .with_url("http://localhost:8123")
        // purposefully invalid credentials in the client configuration for the sake of this example
        .with_user("default")
        .with_password("xiaoxiao")
        .with_database("blklogs");
        // these custom headers will override the auth headers generated by the client
        // .with_header("X-ClickHouse-User", "default");
        ClkHouseHdl { client }
    }

    // 插入
    pub fn insert<T>(&self, sql:&str) -> Result<(), Box<dyn Error>> 
    where T: Row,
    {
        let _ = self.client.insert::<T>(sql);
        Ok(())
    }

    // 批量插入
    pub async fn inserts<T>(&self, sql:&str, rows: Vec<T>) -> Result<bool, Box<dyn Error>> 
    where T: Row + Serialize,
    {
        let mut insert = self.client.insert(sql)?;
        for row in rows {
            insert.write(&row).await?;
        }
        insert.end().await?;
        Ok(true)
    }

    // 更新
    pub async fn update(&self, sql:&str) -> Result<(), Box<dyn Error>>
    {
        // clickhouse不支持update操作
        // 需要使用 ALTER TABLE ... UPDATE 语法
        let _ = self.client.query(sql).execute().await?;
        Ok(())
    }

    // 删除
    pub async fn del(&self, sql:&str) -> Result<bool, Box<dyn Error>>
    {
        let _ = self.client.query(sql).execute().await?;
        Ok(true)
    }

    // 查询列表
    pub async fn querys<T>(&self, query: &str) -> Result<Vec<T>, Box<dyn Error>>
    where T: for<'b> Deserialize<'b> + Serialize + Row,
    {
        let res: Vec<T> = self.client.query(query).fetch_all().await?;
        Ok(res)
    }

    // 查询单个
    pub async fn query<T>(&self, query: &str) -> Result<T, Box<dyn Error>> 
    where T: for<'b> Deserialize<'b> + Serialize + Row,
    {
        let res: T = self.client.query(query).fetch_one().await?;
        Ok(res)
    }

    // 分页查询
    pub async fn query_page<T>(&self, sql: &str, pages: i32, sizes: i32) -> Result<(i32,Vec<T>), Box<dyn Error>>
    where T: for<'a> Deserialize<'a> + Serialize + Row + std::fmt::Debug,
    {
        // 计算偏移量
        let offset = (pages - 1) * sizes;
        
        // 构建分页SQL
        let pg_sql = format!("{} LIMIT {} OFFSET {}", sql.trim_end_matches(';'), sizes, offset);
        let count_sql = format!("SELECT count(*) as total FROM ({}) as t", sql.trim_end_matches(';'));

        println!("{} \r\n {}", &pg_sql, &count_sql);

        // 获取总记录数
        // let total: i32 = self.client.query(&count_sql)
        //     .fetch_one()
        //     .await?;
        
        let total: i32 = match self.client.query(&count_sql).fetch_one().await {
            Ok(counts) => counts,
            Err(e) => {
                println!("总记录数查询失败: {}, \r\n 请检查URL是否正确,例如:http://default:xiaoxiao@192.168.30.111:8123", e);
                return Err(Box::new(e));
            }
        };

        // 获取分页数据
        // let data: Vec<T> = self.client.query(&pg_sql)
        //     .fetch_all().await?;
        // println!("data is: {data:?}");
        // for row in &data {
        //     println!("row is: {row:?}");
        // }

        // let rst: NaiveDateTime = self.client.query("select intime from my_table limit 1")
        //     .fetch_one::<NaiveDateTime>()
        //     .await?;
        // println!("name is: {rst:?}");
        
        println!("{}, {}", &pg_sql, total);
        let data: Vec<T> = match self.client.query(&pg_sql).fetch_all().await {
            Ok(res) => {
                println!("{res:?}"); // println!("分页查询成功: {}", result.len());
                println!("返回结果的类型: {:?}", std::any::type_name::<T>()); // 打印返回结果的类型
                res
            },
            Err(e) => {
                println!("分页查询失败: {}, \r\n 请检查URL是否正确,例如:http://default:xiaoxiao@192.168.30.111:8123", e);
                return Err(Box::new(e));
            }
        };

        Ok((total,data))
    }
}